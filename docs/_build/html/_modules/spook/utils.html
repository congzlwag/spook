<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spook.utils &#8212; Spectral-Domain Ghost Imaging 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for spook.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sps</span>

<span class="c1"># from matplotlib import pyplot as plt</span>

<div class="viewcode-block" id="laplacian1D_S">
<a class="viewcode-back" href="../../spook.html#spook.utils.laplacian1D_S">[docs]</a>
<span class="k">def</span> <span class="nf">laplacian1D_S</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">Lmat</span> <span class="o">=</span> <span class="n">sps</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Lmat</span> <span class="o">+=</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sps</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Lmat</span></div>


<div class="viewcode-block" id="laplacian_square_S">
<a class="viewcode-back" href="../../spook.html#spook.utils.laplacian_square_S">[docs]</a>
<span class="k">def</span> <span class="nf">laplacian_square_S</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">drop_bound</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">laplacian1D_S</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">drop_bound</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">tocsc</span><span class="p">())[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">L</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">L</span></div>


<div class="viewcode-block" id="worth_sparsify">
<a class="viewcode-back" href="../../spook.html#spook.utils.worth_sparsify">[docs]</a>
<span class="k">def</span> <span class="nf">worth_sparsify</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">arr</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">3</span><span class="o">*</span><span class="n">arr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="calcL2fromContracted">
<a class="viewcode-back" href="../../spook.html#spook.utils.calcL2fromContracted">[docs]</a>
<span class="k">def</span> <span class="nf">calcL2fromContracted</span><span class="p">(</span><span class="n">Xo</span><span class="p">,</span> <span class="n">AtA</span><span class="p">,</span> <span class="n">Bcontracted</span><span class="p">,</span> <span class="n">trBtB</span><span class="p">,</span> <span class="n">GtG</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the residual L2 norm from the contracted tensors.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ------</span>
<span class="sd">    Xo: ndarray, value of the optimization variable</span>
<span class="sd">    AtA: ndarray, AtA matrix</span>
<span class="sd">    Bcontracted: ndarray, AtB matrix if G is None, otherwise Bcontracted = AtB @ G</span>
<span class="sd">    trBtB: float, constant in the mean square error</span>
<span class="sd">    GtG: ndarray, (optional) GtG matrix. If None, it means G=identity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quad</span> <span class="o">=</span> <span class="n">Xo</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">AtA</span> <span class="o">@</span> <span class="n">Xo</span>
    <span class="k">if</span> <span class="n">GtG</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">quad</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">quad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">quad</span> <span class="o">@</span> <span class="n">GtG</span><span class="p">)</span>
    <span class="n">lin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">Xo</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Bcontracted</span><span class="p">)</span> <span class="c1"># This covered the contraction with G</span>
    <span class="n">const</span> <span class="o">=</span> <span class="n">trBtB</span>
    <span class="n">rl2</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">quad</span><span class="o">+</span><span class="n">lin</span><span class="o">+</span><span class="n">const</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">rl2</span></div>


<div class="viewcode-block" id="matricize_tensor_bykey">
<a class="viewcode-back" href="../../spook.html#spook.utils.matricize_tensor_bykey">[docs]</a>
<span class="k">def</span> <span class="nf">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">ky_list</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">N1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="n">ky_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ky_list</span><span class="p">),</span> <span class="n">N1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ky</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ky_list</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">dct</span><span class="p">[</span><span class="n">ky</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sps</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">tmp</span><span class="p">[</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">roi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="dict_innerprod">
<a class="viewcode-back" href="../../spook.html#spook.utils.dict_innerprod">[docs]</a>
<span class="k">def</span> <span class="nf">dict_innerprod</span><span class="p">(</span><span class="n">dictA</span><span class="p">,</span> <span class="n">dictB</span><span class="p">,</span> <span class="n">Aroi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inner product of two tensors represented as dictionaries,</span>
<span class="sd">    with the contracted dimension being the keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lsta</span><span class="p">,</span> <span class="n">keys</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dictA</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictB</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">lsta</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Keys mismatch.&quot;</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># ROI</span>
    <span class="k">if</span> <span class="n">Aroi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">dictA</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;ROI is not supported for ndim&gt;2 data.&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Aroi</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Aroi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Aroi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">),</span> \
        <span class="s2">&quot;Unrecognized ROI for A: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Aroi</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">Aroi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Aroi</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">Aroi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">Aroi</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictB</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictA</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">Aroi</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B</span>
    <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
        <span class="c1"># print(&quot;Chunk accumulating&quot;)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">key_segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">//</span><span class="n">chunk_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">key_segs</span> <span class="o">=</span> <span class="n">key_segments</span>
        <span class="k">for</span> <span class="n">ky_seg</span> <span class="ow">in</span> <span class="n">key_segs</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictA</span><span class="p">,</span> <span class="n">ky_seg</span><span class="p">,</span> <span class="n">Aroi</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictB</span><span class="p">,</span> <span class="n">ky_seg</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="dict_allsqsum">
<a class="viewcode-back" href="../../spook.html#spook.utils.dict_allsqsum">[docs]</a>
<span class="k">def</span> <span class="nf">dict_allsqsum</span><span class="p">(</span><span class="n">dictB</span><span class="p">):</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dictB</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictB</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">key_segments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span><span class="o">//</span><span class="n">chunk_size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">key_segs</span> <span class="o">=</span> <span class="n">key_segments</span>
        <span class="k">for</span> <span class="n">ky_seg</span> <span class="ow">in</span> <span class="n">key_segs</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">matricize_tensor_bykey</span><span class="p">(</span><span class="n">dictB</span><span class="p">,</span> <span class="n">ky_seg</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">B</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="iso_struct">
<a class="viewcode-back" href="../../spook.html#spook.utils.iso_struct">[docs]</a>
<span class="k">def</span> <span class="nf">iso_struct</span><span class="p">(</span><span class="n">csc_mata</span><span class="p">,</span> <span class="n">csc_matb</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether two csc sparse matrices share the same structure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">csc_mata</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">csc_matb</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">csc_mata</span><span class="o">.</span><span class="n">indices</span> <span class="o">==</span> <span class="n">csc_matb</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">res</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">csc_mata</span><span class="o">.</span><span class="n">indptr</span> <span class="o">==</span> <span class="n">csc_matb</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="count_delaybin">
<a class="viewcode-back" href="../../spook.html#spook.utils.count_delaybin">[docs]</a>
<span class="k">def</span> <span class="nf">count_delaybin</span><span class="p">(</span><span class="n">at_iter</span><span class="p">):</span>
    <span class="n">at_vals</span> <span class="o">=</span> <span class="n">at_iter</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">at_iter</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">at_iter</span>
    <span class="n">tlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">at_vals</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span>  <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">tlist</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="eval_Nw">
<a class="viewcode-back" href="../../spook.html#spook.utils.eval_Nw">[docs]</a>
<span class="k">def</span> <span class="nf">eval_Nw</span><span class="p">(</span><span class="n">at_iter</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">at_iter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">at_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">at</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">at_iter</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="eval_Ng">
<a class="viewcode-back" href="../../spook.html#spook.utils.eval_Ng">[docs]</a>
<span class="k">def</span> <span class="nf">eval_Ng</span><span class="p">(</span><span class="n">b_iter</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b_iter</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b0</span> <span class="ow">in</span> <span class="n">b_iter</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sps</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">b0</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">b0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">b0</span><span class="o">.</span><span class="n">size</span>
    <span class="k">return</span> <span class="n">b_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span></div>



<span class="c1"># def scan_lsparse(spk, lsparse_list, calc_curvature=True, plot=False):</span>
<span class="c1">#     assert hasattr(spk, &quot;_TrBtB&quot;) and spk._TrBtB &gt; 0, &quot;To scan l_sparse, make sure spk._TrBtB is cached.&quot;</span>
<span class="c1">#     res = np.zeros((len(lsparse_list),3))</span>
<span class="c1">#     for ll, lsp in enumerate(lsparse_list):</span>
<span class="c1">#         spk.solve(lsp, None)</span>
<span class="c1">#         res[ll,:] = [lsp, spk.residueL2(), spk.sparsity()]</span>
<span class="c1">#     idc = np.argsort(res[:,0])</span>
<span class="c1">#     res = res[idc]</span>
<span class="c1">#     if not calc_curvature:</span>
<span class="c1">#         return res</span>
<span class="c1">#     Ninterp_min = 101 # Minimal Number of points in interpolation</span>
<span class="c1">#     margin = 2  # Number of interpolated points to be ignored at the boundaries during differentiation</span>
<span class="c1">#     res_alllg = np.log10(res)</span>
<span class="c1">#     spls = [interp1d(res_alllg[:,0],res_alllg[:,i],&quot;cubic&quot;,fill_value=&quot;extrapolate&quot;) for i in range(1,3)]</span>
<span class="c1">#     ll = np.linspace(res_alllg[0,0],res_alllg[-1,0],max(2*len(lsparse_list)-1,Ninterp_min))[margin:-margin]</span>
<span class="c1">#     # Try using spl._spline.derivative</span>
<span class="c1">#     rr = np.asarray([s(ll) for s in spls])</span>
<span class="c1">#     tt = np.asarray([(s._spline.derivative(1))(ll) for s in spls])</span>
<span class="c1">#     qq = np.asarray([(s._spline.derivative(2))(ll) for s in spls])</span>
<span class="c1">#     kk = np.cross(tt,qq,axisa=0,axisb=0).ravel()</span>
<span class="c1">#     ss = np.linalg.norm(tt, axis=0).ravel()</span>
<span class="c1">#     kk /= ss**3 # curvature</span>
<span class="c1">#     curv_dat = np.vstack((ll,rr,ss,kk)).T</span>
<span class="c1">#     valid_lam_range = np.arange(ll.size)[ss &gt; 1e-2*ss.max()]</span>
<span class="c1">#     curv_dat = curv_dat[valid_lam_range[0]:valid_lam_range[-1]+1]</span>
<span class="c1">#     # print(plot)</span>
<span class="c1">#     if plot:</span>
<span class="c1">#         # print(&quot;Calling show_lcurve&quot;)</span>
<span class="c1">#         show_lcurve(res_alllg, curv_dat, plot)</span>
<span class="c1">#     idM = np.argmax(curv_dat[:,-1])</span>
<span class="c1">#     print(curv_dat[idM,0])</span>
<span class="c1">#     spk.solve(10**(curv_dat[idM,0]), None)</span>
<span class="c1">#     return res, curv_dat</span>

<span class="c1"># def show_lcurve(log_scan_results, curv_dat, fig):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Plot the data in a L-curve scan.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     ax0 = fig.add_subplot(1,2,1)</span>
<span class="c1">#     sc = ax0.scatter(log_scan_results[:,1],log_scan_results[:,2], c=log_scan_results[:,0])</span>
<span class="c1">#     cax = fig.colorbar(sc,ax=ax0)</span>
<span class="c1">#     cax.set_label(r&quot;$\lg \lambda_{sp}$&quot;)</span>
<span class="c1">#     ax0.plot(curv_dat[:,1],curv_dat[:,2],&#39;k&#39;)</span>
<span class="c1">#     ax0.set_xlabel(r&quot;$\lg \|AX-B\|_2$&quot;)</span>
<span class="c1">#     ax0.set_ylabel(r&quot;$\lg h_{sp}(X)$&quot;)</span>
<span class="c1">#     ax2 = fig.add_subplot(2,2,2)</span>
<span class="c1">#     ax2.plot(curv_dat[:,0],curv_dat[:,3])</span>
<span class="c1">#     ax2.set_ylabel(r&quot;|Tangent Vec|&quot;)</span>
<span class="c1">#     ax3 = fig.add_subplot(2,2,4)</span>
<span class="c1">#     ax3.plot(curv_dat[:,0],curv_dat[:,4])</span>
<span class="c1">#     ax3.set_xlabel(r&quot;$\lg \lambda_{sp}$&quot;)</span>
<span class="c1">#     ax3.set_ylabel(r&quot;Curvature&quot;)</span>
<span class="c1">#     idM = np.argmax(curv_dat[:,-1])</span>
<span class="c1">#     ax0.plot(curv_dat[idM,1],curv_dat[idM,2], &quot;r+&quot;)</span>
<span class="c1">#     ax3.plot(curv_dat[idM,0],curv_dat[idM,4], &quot;r+&quot;)</span>
<span class="c1">#     fig.tight_layout()</span>
<span class="c1">#     return fig, idM</span>

<div class="viewcode-block" id="poisson_nll">
<a class="viewcode-back" href="../../spook.html#spook.utils.poisson_nll">[docs]</a>
<span class="k">def</span> <span class="nf">poisson_nll</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">pred_msk</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pred_msk</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">pred_msk</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="soft_poisson_nll">
<a class="viewcode-back" href="../../spook.html#spook.utils.soft_poisson_nll">[docs]</a>
<span class="k">def</span> <span class="nf">soft_poisson_nll</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sps</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">pred</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">pred</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">msk</span><span class="p">]</span>
    <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">msk</span><span class="p">]</span>
    <span class="n">pois_msk</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">&gt;</span> <span class="n">p</span>
    <span class="n">gaus_msk</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">&lt;=</span><span class="n">p</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">pois_msk</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">pois_msk</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">pois_msk</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">pred</span><span class="p">[</span><span class="n">pois_msk</span><span class="p">])</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">gaus_msk</span><span class="p">]</span>
    <span class="n">ret</span><span class="p">[</span><span class="n">gaus_msk</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">pred</span><span class="p">[</span><span class="n">gaus_msk</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">p</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Spectral-Domain Ghost Imaging</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">spook</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Jun Wang, Bucksbaum Group.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>